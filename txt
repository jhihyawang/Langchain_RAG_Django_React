    def group_tables_summary(self, table_blocks, table_results):
        # 分組連續同 header
        groups = []
        for block in sorted(table_blocks, key=lambda x: x['page']):
            if groups and block['page'] == groups[-1][-1]['page'] + 1 and block['header'] == groups[-1][-1]['header']:
                groups[-1].append(block)
            else:
                groups.append([block])
        # 處理每組
        for grp in groups:
            # 合併圖
            imgs = [Image.open(b['path']) for b in grp]
            widths, heights = zip(*(i.size for i in imgs))
            total_h = sum(heights) + 30 * len(imgs)
            max_w = max(widths)
            merged = Image.new('RGB', (max_w, total_h), 'white')
            draw = ImageDraw.Draw(merged)
            y = 0
            font = ImageFont.load_default()
            for b, im in zip(grp, imgs):
                tag = f"=== Page {b['page']} ==="
                draw.text((0, y), tag, fill='black', font=font)
                y += 20
                merged.paste(im, (0, y))
                y += im.height + 10
            merged_path = os.path.join(self.output_dir, f"merged_{grp[0]['page']}_{grp[-1]['page']}.png")
            merged.save(merged_path)
            # 提示並摘要
            prompt = (
                "以下圖片包含多頁連續表格，已用 '=== Page X ===' 標籤標註頁碼，"
                "請針對每個區段以其標籤拆分並回傳對應 markdown 表格。"
            )
            resp = self.summarize_image(merged_path, prompt)
            # 解析回傳
            pattern = r"=== Page (\d+) ===\s*([\s\S]*?)(?=(?:=== Page \d+ ===)|$)"
            for m in re.finditer(pattern, resp):
                pg = int(m.group(1))
                md = m.group(2).strip()
                table_results.append({
                    'page': pg,
                    'source': next(b['path'] for b in grp if b['page']==pg),
                    'content': md,
                    'media_type': 'table'
                })
        return table_results
