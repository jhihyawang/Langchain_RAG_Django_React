import React, { useEffect, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import API_BASE_URL from "../api";

const KnowledgeEditPage = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  const [title, setTitle] = useState("");
  const [pageGroups, setPageGroups] = useState([]);
  const [modifiedChunks, setModifiedChunks] = useState(new Set());
  const [editModeMap, setEditModeMap] = useState({});
  const [searchText, setSearchText] = useState("");

  useEffect(() => {
    fetch(`${API_BASE_URL}/api/knowledge/${id}/chunks/`)
      .then((res) => res.json())
      .then((data) => {
        setTitle((data.title || "").replace(/\.pdf$/i, ""));
        const grouped = groupChunks(data.chunks || []);
        setPageGroups(grouped);
      })
      .catch((err) => console.error("âŒ è¼‰å…¥ chunks å¤±æ•—", err));
  }, [id]);

  const groupChunks = (chunks) => {
    const pages = {};
    for (const chunk of chunks) {
      const pageKey = chunk.page_number;
      if (!pages[pageKey]) pages[pageKey] = { page_number: pageKey, groups: [] };
      const sourceKey = Array.isArray(chunk.source)
        ? chunk.source[0]
        : typeof chunk.source === "string"
        ? chunk.source
        : `text-${chunk.id}`;
      const subGroupKey = `${chunk.media_type}-${sourceKey}`;
      let subGroup = pages[pageKey].groups.find((g) => g.key === subGroupKey);
      if (!subGroup) {
        subGroup = {
          key: subGroupKey,
          media_type: chunk.media_type,
          source: sourceKey,
          chunks: [],
        };
        pages[pageKey].groups.push(subGroup);
      }
      subGroup.chunks.push(chunk);
    }
    return Object.values(pages);
  };

  const handleChunkEdit = (chunkId, newContent) => {
    setPageGroups((prev) =>
      prev.map((page) => ({
        ...page,
        groups: page.groups.map((group) => ({
          ...group,
          chunks: group.chunks.map((chunk) =>
            chunk.id === chunkId ? { ...chunk, content: newContent } : chunk
          ),
        })),
      }))
    );
  };

  const handleDeleteChunk = async (chunkId) => {
    if (!window.confirm("ç¢ºå®šè¦åˆªé™¤æ­¤å€å¡Šå—ï¼Ÿ")) return;
    try {
      const res = await fetch(`${API_BASE_URL}/api/knowledge/chunk/${chunkId}/`, {
        method: "DELETE",
      });
      if (res.status === 204) {
        setPageGroups((prev) =>
          prev
            .map((page) => ({
              ...page,
              groups: page.groups
                .map((group) => ({
                  ...group,
                  chunks: group.chunks.filter((chunk) => chunk.id !== chunkId),
                }))
                .filter((group) => group.chunks.length > 0),
            }))
            .filter((page) => page.groups.length > 0)
        );
      } else {
        alert("âŒ åˆªé™¤å¤±æ•—");
      }
    } catch (err) {
      console.error("âŒ åˆªé™¤ chunk å¤±æ•—", err);
    }
  };

  const handleSaveAll = async () => {
    try {
      for (const page of pageGroups) {
        for (const group of page.groups) {
          for (const chunk of group.chunks) {
            await fetch(`${API_BASE_URL}/api/knowledge/chunk/${chunk.id}/`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ content: chunk.content }),
            });
          }
        }
      }
      alert("âœ… æ‰€æœ‰å€å¡Šå·²æˆåŠŸæ›´æ–°ï¼");
      navigate("/document");
    } catch (err) {
      console.error("âŒ å„²å­˜å¤±æ•—", err);
      alert("âŒ å„²å­˜å¤±æ•—");
    }
  };

  const toggleEditMode = (chunkId) => {
    setEditModeMap((prev) => ({
      ...prev,
      [chunkId]: !prev[chunkId],
    }));
  };

  const mediaTypeLabel = {
    text: "æ–‡å­—ç¾¤çµ„",
    table: "è¡¨æ ¼ç¾¤çµ„",
    image: "åœ–ç‰‡ç¾¤çµ„",
  };

  const mediaTypeBadgeClass = {
    text: "badge bg-secondary",
    table: "badge bg-success",
    image: "badge bg-info",
  };

  return (
    <div className="container mt-4">
      <h3>ğŸ“ ç·¨è¼¯æ–‡ä»¶å…§å®¹ï¼ˆID: {id}ï¼‰</h3>
      <p>æª”æ¡ˆåç¨±ï¼š{title}</p>
      <input
        type="text"
        className="form-control mb-3"
        placeholder="ğŸ” æœå°‹ chunk å…§å®¹é—œéµå­—..."
        value={searchText}
        onChange={(e) => setSearchText(e.target.value)}
      />
      {pageGroups.map((page) => {
        // ç¯©é¸æ¯é çš„ group.chunksï¼Œåˆ¤æ–·æ˜¯å¦æœ‰å…§å®¹åŒ…å«é—œéµå­—
        const filteredGroups = page.groups
          .map((group) => {
            const filteredChunks = group.chunks.filter((chunk) =>
              chunk.content.toLowerCase().includes(searchText.toLowerCase())
            );
            return filteredChunks.length > 0
              ? { ...group, chunks: filteredChunks }
              : null;
          })
          .filter((g) => g !== null);

        if (filteredGroups.length === 0) return null;

        return (
          <div key={page.page_number} className="mb-4 border rounded p-3 bg-light">
            <h5>ğŸ“„ é ç¢¼ï¼š{page.page_number}</h5>

            {filteredGroups.map((group, gIdx) => (
              <div key={`${page.page_number}-${gIdx}`} className="mb-4">
                <h6 className="mb-2">
                  <span className={mediaTypeBadgeClass[group.media_type] || "badge bg-dark"}>
                    {mediaTypeLabel[group.media_type] || "æœªçŸ¥ç¾¤çµ„"}
                  </span>
                </h6>

                {group.media_type !== "text" && group.source && (
                  <div className="mb-2 text-center">
                    <img
                      src={`${API_BASE_URL}/${group.source}`}
                      alt={`group-${gIdx}`}
                      style={{
                        maxWidth: "100%",
                        maxHeight: "300px",
                        border: "1px solid #ccc",
                      }}
                    />
                  </div>
                )}

                {group.chunks.map((chunk) => (
                  <div className="card my-2" key={chunk.id}>
                    <div className="card-header d-flex justify-content-between align-items-center">
                      <span>
                        ğŸ§© Chunk #{chunk.chunk_index}
                        {modifiedChunks.has(chunk.id) && (
                          <span className="text-warning ms-2">ğŸŸ¡ å·²ä¿®æ”¹</span>
                        )}
                      </span>
                      <div>
                        <button
                          className="btn btn-sm btn-secondary me-2"
                          onClick={() => toggleEditMode(chunk.id)}
                        >
                          {editModeMap[chunk.id] ? "é è¦½" : "ç·¨è¼¯"}
                        </button>
                        <button
                          className="btn btn-sm btn-danger"
                          onClick={() => handleDeleteChunk(chunk.id)}
                        >
                          ğŸ—‘ï¸ åˆªé™¤
                        </button>
                      </div>
                    </div>
                    <div className="card-body">
                      {editModeMap[chunk.id] ? (
                        <textarea
                          className="form-control mb-2"
                          rows="5"
                          value={chunk.content}
                          onChange={(e) => {
                            handleChunkEdit(chunk.id, e.target.value);
                            setModifiedChunks((prev) => {
                              const next = new Set(prev);
                              next.add(chunk.id);
                              return next;
                            });
                          }}
                        ></textarea>
                      ) : (
                        <div
                          className="prose max-w-full"
                          style={{
                            background: "#f8f9fa",
                            padding: "8px",
                            borderRadius: "6px",
                            minHeight: "2.5em",
                          }}
                        >
                          <ReactMarkdown children={chunk.content} remarkPlugins={[remarkGfm]} />
                        </div>
                      )}
                      <div className="text-muted small mt-2">
                        ğŸ”— ä¾†æºï¼š<code>{group.source}</code>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            ))}
          </div>
        );
      })}

      <button className="btn btn-success w-100 mt-4" onClick={handleSaveAll}>
        ğŸ’¾ å„²å­˜æ‰€æœ‰è®Šæ›´
      </button>
    </div>
  );
};

export default KnowledgeEditPage;
