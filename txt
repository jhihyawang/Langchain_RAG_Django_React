import io
import json
import os
import re
import time
from datetime import datetime

import cv2
import fitz  # PyMuPDF
import numpy as np
import ollama
import pdfplumber
import torch
from easyocr import Reader
from pdf2image import convert_from_path
from PIL import Image, ImageDraw
from transformers import AutoModelForObjectDetection, AutoProcessor


def log(msg):
    now = datetime.now().strftime("[%Y-%m-%d %H:%M:%S]")
    print(f"{now} {msg}")

class PdfProcessor:
    def __init__(self, pdf_path, output_dir="media/extract_data", model_name="gemma3:27b", knowledge_id=None, vectorstore=None,cid_threshold=20):
        self.pdf_path = pdf_path
        self.file_stem = os.path.splitext(os.path.basename(pdf_path))[0]
        self.output_dir = os.path.join(output_dir, self.file_stem)
        self.model_name = model_name
        self.knowledge_id = knowledge_id
        self.device = "cuda" if torch.cuda.is_available() else "cpu"
        self.reader = Reader(['ch_tra', 'en'], gpu=torch.cuda.is_available())
        self.detector = AutoModelForObjectDetection.from_pretrained("microsoft/table-transformer-detection", revision="no_timm").to(self.device)
        self.processor = AutoProcessor.from_pretrained("microsoft/table-transformer-detection", revision="no_timm")
        self.cid_threshold = cid_threshold
        #self.vectorstore = vectorstore or VectorStoreHandler(db_path="chroma_user_db")
        self.log = log
        os.makedirs(self.output_dir, exist_ok=True)
        os.makedirs(os.path.join(self.output_dir, "images"), exist_ok=True)
        os.makedirs(os.path.join(self.output_dir, "tables"), exist_ok=True)
        os.makedirs(os.path.join(self.output_dir, "ocr_fallback"), exist_ok=True)

    # def should_ocr(self, text):
    #     cid_count = text.count("(cid:")
    #     return cid_count > 15 or (len(text) > 0 and cid_count / len(text) > 0.3) or not bool(re.search(r"[\u4e00-\u9fa5a-zA-Z]", text))

    def should_ocr(self, text):
        cid_unicode_count = len(re.findall(r'[\ue000-\uf8ff]', text))
        cid_marker_count = len(re.findall(r'\(cid:\d+\)', text))
        cid_count = cid_unicode_count + cid_marker_count
        if cid_count >= self.cid_threshold:
            print(f"CID é” {cid_count}ï¼Œä½¿ç”¨ OCR å¿«å–")
            return True
        else:
            print(f"æ–‡å­—ç¬¦åˆæ¨™æº–ï¼Œä½¿ç”¨pdfplumber")
            return False

    def summarize_image(self, image_paths, prompt):
        if isinstance(image_paths, str):
            image_paths = [image_paths]
        log("[è§£æåœ–ç‰‡æˆ–æ•´é å½±åƒ]")
        system_prompt = "ä½ æ˜¯ä¸€ä½é‡å°åœ–ç‰‡å½±åƒå’Œè¡¨æ ¼å½±åƒé€²è¡Œæå–å…§å®¹çš„åŠ©æ‰‹ï¼Œè«‹ä»¥æ•˜è¿°è€…çš„è§’åº¦èªªæ˜æ¯å¼µåœ–ç‰‡ä¸­çš„è³‡æ–™æˆ–æ–‡æœ¬å…§å®¹ï¼Œä¾‹å¦‚æ•¸æ“šã€æ–‡å­—ç­‰ï¼Œè‹¥æ˜¯åœ–è¡¨ä¹Ÿè«‹èªªæ˜å…¶è¶¨å‹¢èˆ‡é—œéµæ•¸æ“š"
        try:
            response = ollama.chat(
                model=self.model_name,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": prompt, "images": image_paths}
                ]
            )
            return response['message']['content']
        except Exception as e:
            return f"âŒ åœ–åƒåˆ†æéŒ¯èª¤: {str(e)}"

    def detect_rotation_angle_easyocr(self, ocr_result, min_text_count=5, vertical_angle_range=(75, 105)):
        vertical_texts, short_texts, tall_boxes = 0, 0, 0
        total_texts = len(ocr_result)
        for (box, text, _) in ocr_result:
            x0, y0 = box[0]; x1, y1 = box[1]
            dx, dy = x1 - x0, y1 - y0
            angle = abs(np.arctan2(dy, dx) * 180 / np.pi)
            if vertical_angle_range[0] <= angle <= vertical_angle_range[1]: vertical_texts += 1
            if len(text.strip()) <= 1: short_texts += 1
            w = np.linalg.norm(np.array(box[0]) - np.array(box[1]))
            h = np.linalg.norm(np.array(box[0]) - np.array(box[3]))
            if h > w * 2: tall_boxes += 1
        if total_texts < min_text_count: return 0
        if vertical_texts / total_texts > 0.5 or short_texts / total_texts > 0.4 or tall_boxes / total_texts > 0.4:
            return 90
        return 0
        
    def get_title_from_above(self, img, coords):
        # è¨ˆç®—æ¨™é¡Œç¯„åœ
        x1, y1, x2, y2 = coords
        print(f"è¡¨æ ¼æå–ç¯„åœ:{[x1, y1, x2, y2]}")

        # Xè»¸ç¯„åœï¼šå¾è¡¨æ ¼æœ€å·¦é‚Šåˆ°è¡¨æ ¼å¯¬åº¦çš„ 3/4
        x_range = (x1, x1 + (x2 - x1) * 0.75)
        
        # Yè»¸ç¯„åœï¼šå¾è¡¨æ ¼ä¸Šæ–¹çš„ç©ºé–“çš„ 1/2 é–‹å§‹åˆ°è¡¨æ ¼ä¸Šé‚Šç·£
        y_range = (y1-100, y1)

        print(f"æ¨™é¡Œæå–ç¯„åœ:{[x_range[0], y_range[0], x_range[1], y_range[1]]}")
                # åœ¨åŸå§‹åœ–åƒä¸Šç•«å‡ºæ¨™é¡Œç¯„åœ
                
        draw = ImageDraw.Draw(img)
        draw.rectangle([x_range[0], y_range[0], x_range[1], y_range[1]], outline="red", width=3)

        # é¡¯ç¤ºåœ–ç‰‡
        img.show()
        # è£åˆ‡åœ–ç‰‡
        crop = img.crop((x_range[0], y_range[0], x_range[1], y_range[1]))

        # ä½¿ç”¨OCRè®€å–è£åˆ‡å€åŸŸçš„æ–‡å­—
        result = self.reader.readtext(np.array(crop))

        # å°‡æ‰€æœ‰æ–‡å­—åˆä½µç‚ºä¸€å€‹å­—ä¸²ï¼Œç”¨æ›è¡Œåˆ†éš”
        return "\n".join([item[1] for item in result]) if result else "ç„¡æ¨™é¡Œ"

    def rotate_original_pdf(self, file_path, rotated_pages):
        log("rotate this file")
        doc = fitz.open(file_path)
        for page_index in rotated_pages:
            page = doc[page_index - 1]
            page.set_rotation((page.rotation + 90) % 360)
            log(f"========== Page {page_index} has been rotated 90 degrees ==========")

        temp_path = file_path + ".rotated.pdf"
        doc.save(temp_path)
        doc.close()

        # åˆªé™¤èˆŠæ–‡ä»¶ï¼Œç„¶å¾Œé‡å‘½åæ–°æ–‡ä»¶
        try:
            os.remove(file_path)  # åˆªé™¤åŸæ–‡ä»¶
            os.rename(temp_path, file_path)  # é‡å‘½åè‡¨æ™‚æª”æ¡ˆ
            log(f"æª”æ¡ˆå·²æˆåŠŸæ›¿æ›ï¼š{file_path}")
        except PermissionError as e:
            log(f"ç„¡æ³•æ›¿æ›æª”æ¡ˆï¼š{e}")
            raise

        return file_path
    
    def calculate_table_area_each_page(self,box,total_table_area) -> float:
        x1, y1, x2, y2 = box
        table_area = abs((x2 - x1) * (y2 - y1))
        total_table_area += table_area
        return total_table_area
        
    def extract_table(self,img,i,j,box,table_blocks):
        coords = box.tolist()  # [x1, y1, x2, y2]
        expand_coords = [
            min(coords[0] - 50, coords[0]),
            min(coords[1] - 50, coords[1]),
            max(coords[2] + 50, coords[2]),
            max(coords[3] + 50, coords[3])
        ]
        cropped = img.crop(expand_coords)
        path = os.path.join(self.output_dir, "tables", f"page{i}_table{j+1}.png")
        cropped.save(path)
        ocr = self.reader.readtext(np.array(cropped))
        merged = "\n".join([r[1] for r in ocr])
        box_width = coords[2] - coords[0]
        table_title = self.get_title_from_above(img, coords)
        print(f"æª¢æ¸¬åˆ°çš„æ¨™é¡Œï¼š{table_title}")
        table_blocks.append({
            "page": i,
            "image": path,
            "ocr_text": merged,
            "box_width": box_width,
            "title": table_title
        })
        return table_blocks

    def group_tables_summary(self,table_blocks,table_results):
        # è¡¨æ ¼ç¾¤çµ„é‚è¼¯
        table_blocks.sort(key=lambda x: x["page"])
        grouped, temp = [], [table_blocks[0]] if table_blocks else []

        for i in range(1, len(table_blocks)):
            print("===== groping table =====")
            prev, curr = table_blocks[i-1], table_blocks[i]
            if (
                curr["page"] == prev["page"] + 1
                and abs(curr["box_width"] - prev["box_width"]) / max(prev["box_width"], 1) < 0.1
                and curr["title"] == "ç„¡æ¨™é¡Œ" 
            ):
                temp.append(curr)
            else:
                grouped.append(temp)
                temp = [curr]
        if temp: grouped.append(temp)

        for group_index, group in enumerate(grouped):
            texts = [g["ocr_text"] for g in group]
            imgs = [g["image"] for g in group]
            pages = [g["page"] for g in group]
            title = [g["title"] for g in group][0] #è·¨é è¡¨æ ¼ä»¥ç¬¬ä¸€å€‹è¡¨æ ¼æ¨™é¡Œ(å› ç‚ºå…¶ä»–çš„æ‡‰è©²éƒ½æ˜¯"ç„¡æ¨™é¡Œ")
            print(f"Title: {title}")
            print(f"OCR: {texts}")
            prompt = (
                f"ä»¥ä¸‹æ˜¯è¡¨æ ¼æ¨™é¡Œï¼š{title}\nä»¥ä¸‹æ˜¯ OCR å…§å®¹ï¼š\n{chr(10).join(texts)}\n"
                f"è«‹çµ±æ•´æ‘˜è¦å¦‚ä¸‹ï¼š\n1. è¡¨æ ¼ä¸»é¡Œ\n2. æ¯å€‹æ¬„ä½çš„æ„ç¾©\n3. æ•¸æ“šè¶¨å‹¢èˆ‡é‡é»"
            )
            summary = self.summarize_image(imgs, prompt)
            log(f"ğŸ“‹ è¡¨æ ¼çµ„ {group_index + 1} æ‘˜è¦å®Œæˆï¼š{summary[:80]}...")
            table_results.append({
                "page": pages,
                "source": imgs,
                "title": title,
                "content": f"è¡¨æ ¼æ¨™é¡Œ: {title}\n[ocr]\n{chr(10).join(texts)}\n[llmæ‘˜è¦]\n{summary}"
            })
        return table_results

    def extract_texts(self,page,i,page_images,text_results):
        text = page.extract_text() or ""
        if self.should_ocr(text):
            img = page_images[i]
            path = os.path.join(self.output_dir, "ocr_fallback", f"page_{i}.png")
            img.save(path)
            ocr_result = self.reader.readtext(np.array(img))
            ocr_text = "\n".join([text for _, text, conf in ocr_result if conf > 0.5]) if ocr_result else ""
            prompt = f"ä»¥ä¸‹åœ–ç‰‡æ˜¯ä¸€é PDFæ–‡ä»¶çš„åŸå§‹å…§å®¹å’Œæ“·å–çš„æ–‡å­—å¦‚ä¸‹:{ocr_text.strip()}ï¼Œè«‹ç›´æ¥æ•˜è¿°å…§å®¹é‡é»ï¼Œæ¢åˆ—å…¶é‚è¼¯èˆ‡æ®µè½ï¼Œå‹¿åŠ å…¥å¤šé¤˜å¼•è¨€æˆ–è©•è«–"
            summary = self.summarize_image(path, prompt)
            log(f"ç¬¬ {i} é æ–‡å­— OCR+LLM æ‘˜è¦å®Œæˆï¼š[ocr]{ocr_text.strip()}\n[llm]{summary}")
            text_results.append({
                "page": i,
                "source": "ocr+llm",
                "content": f"[ocr]{ocr_text.strip()}\n[llm]{summary}"
            })
        else:
            log(f"ç¬¬ {i} é ç´”æ–‡å­—è™•ç†å®Œæˆï¼š{text}...")
            text_results.append({
                "page": i,
                "source": "ori",
                "content": text
            })
        return text_results
            
    def extract_imgs(self, doc, i, image_results):
        # è™•ç†åœ–ç‰‡
        fitz_page = doc.load_page(i - 1)
        image_list = fitz_page.get_images(full=True)
        print(f"ğŸ“„ ç¬¬ {i} é æ‰¾åˆ° {len(image_list)} å¼µåœ–ç‰‡")

        for img_index, img_info in enumerate(image_list):
            xref = img_info[0]
            base_image = doc.extract_image(xref)
            image_bytes = base_image["image"]
            image_ext = base_image["ext"]

            # å°‡åœ–ç‰‡è½‰æ›ç‚º PIL åœ–åƒé€²è¡Œ OCR
            img = Image.open(io.BytesIO(image_bytes))
            img_array = np.array(img)
            ocr_result = self.reader.readtext(img_array)
            ocr_text = "\n".join([text for _, text, conf in ocr_result if conf > 0.5]) if ocr_result else ""
            print(f"OCR çµæœ: {ocr_result}")

            # å¦‚æœ OCR çµæœé•·åº¦å°æ–¼ 8 å­—ï¼Œå‰‡ä¸Ÿæ£„åœ–ç‰‡ï¼Œè·³éå„²å­˜
            if len(ocr_text) < 8:
                log(f"âš ï¸ ç¬¬ {i} é ç¬¬ {img_index + 1} å¼µåœ–ç‰‡ OCR çµæœå°‘æ–¼ 8 å­—ï¼Œå·²ç•¥é")
                continue  # è·³éé€™å¼µåœ–ç‰‡ï¼Œç›´æ¥è™•ç†ä¸‹ä¸€å¼µ

            # å„²å­˜åœ–ç‰‡
            img_name = f"page_{i}_img_{img_index + 1}.{image_ext}"
            img_path = os.path.join(self.output_dir, "images", img_name)
            with open(img_path, "wb") as f:
                f.write(image_bytes)
            print(f"åœ–ç‰‡ {img_index + 1} å·²å„²å­˜ï¼š{img_path}")

            # å¦‚æœ OCR çµæœé•·åº¦ç¬¦åˆæ¢ä»¶ï¼Œç¹¼çºŒè™•ç†åœ–ç‰‡æ‘˜è¦
            print(f"OCR çµæœ: {ocr_text}")
            prompt = "è«‹æè¿°åœ–ç‰‡å…§å®¹ï¼Œè‹¥ç‚ºåœ–è¡¨è«‹æŒ‡å‡ºé¡å‹ã€X/Yè»¸æ„ç¾©ã€è¶¨å‹¢èˆ‡é—œéµè®ŠåŒ–ï¼Œè‹¥éåœ–è¡¨è«‹æè¿°ä¸»è¦æ§‹æˆèˆ‡é‡è¦è³‡è¨Š"
            summary = self.summarize_image(img_path, prompt)
            log(f"ğŸ–¼ï¸ ç¬¬ {i} é åœ–ç‰‡æ‘˜è¦å®Œæˆï¼š[ocr]{ocr_text}\n[llm]{summary[:80]}...")

            image_results.append({
                "page": i,
                "source": img_path,
                "content": summary
            })

        return image_results


    def split_pdf(self, pages_per_split_min=30, pages_per_split_max=40):
        # æ‰“é–‹åŸå§‹ PDF æ–‡ä»¶
        doc = fitz.open(self.pdf_path)
        total_pages = doc.page_count

        # è¨ˆç®—æ¯ä»½çš„é æ•¸
        pages_per_split = (total_pages // (total_pages // pages_per_split_max))  # æ¯ä»½å¤§ç´„ 30-40 é 
        if pages_per_split < pages_per_split_min:
            pages_per_split = pages_per_split_min  # ä¿è­‰æ¯å€‹æ–‡ä»¶è‡³å°‘æœ‰ 30 é 

        # å‰µå»ºè¼¸å‡ºç›®éŒ„
        os.makedirs(self.output_dir, exist_ok=True)

        # æ‹†åˆ†æ–‡ä»¶
        split_pdfs = []
        for start_page in range(0, total_pages, pages_per_split):
            end_page = min(start_page + pages_per_split, total_pages)
            
            # æå–æ‹†åˆ†ç¯„åœ
            split_doc = fitz.open()
            for i in range(start_page, end_page):
                split_doc.insert_pdf(doc, from_page=i, to_page=i)
            
            # å„²å­˜æ‹†åˆ†å¾Œçš„ PDF
            split_pdf_name = f"{self.file_stem}_part_{start_page // pages_per_split + 1}.pdf"
            split_pdf_path = os.path.join(self.output_dir, split_pdf_name)
            split_doc.save(split_pdf_path)
            split_pdfs.append(split_pdf_path)
            split_doc.close()
            
            self.log(f"æ‹†åˆ†æ–‡ä»¶ {split_pdf_name} å·²å„²å­˜ï¼Œç¯„åœï¼šç¬¬ {start_page + 1} é  åˆ° ç¬¬ {end_page} é ")

        doc.close()
        return split_pdfs

    # åŸå…ˆä½¿ç”¨ table-transformer çš„è¡¨æ ¼åµæ¸¬æµç¨‹ï¼Œæ”¹ç‚ºä½¿ç”¨ pdfplumber çš„ page.find_tables()
    # ä¸¦ä¸”åƒ…åœ¨éœ€è¦è™•ç†åœ–ç‰‡æ‘˜è¦çš„æƒ…å¢ƒä¸‹æ‰ä½¿ç”¨ convert_from_path
    def process(self,split_index,pdf_split):
        import time
        start_time = time.time()
        text_results, table_results, image_results = [], [], []
        table_pages = []

        doc = fitz.open(pdf_split)
        pdf = pdfplumber.open(pdf_split)

        page_images = []  # å»¶å¾Œè½‰æ›åœ–ç‰‡
        need_page_image = set()

        # é¦–å…ˆæª¢æŸ¥æ˜¯å¦æœ‰è¡¨æ ¼é ï¼Œä¸¦å°‡è¡¨æ ¼é æ¨™è¨˜å‡ºä¾†
        for i, page in enumerate(pdf.pages, start=1):
            log(f"ğŸ” è™•ç†ç¬¬ {i} é ...")

            text = page.extract_text() or ""
            if page.extract_tables():  # å¦‚æœè©²é åŒ…å«è¡¨æ ¼
                table_pages.append(i)
                need_page_image.add(i)

            if self.should_ocr(text):  # åˆ¤æ–·æ˜¯å¦éœ€è¦OCR
                need_page_image.add(i)

            if doc[i - 1].get_images(full=True):  # æª¢æŸ¥æ˜¯å¦æœ‰åœ–ç‰‡
                need_page_image.add(i)

        # åªè½‰æ›éœ€è¦çš„é é¢åœ–ç‰‡
        if need_page_image:
            log(f"ğŸ–¼ï¸ convert_from_path è½‰æ›é é¢: {sorted(need_page_image)}")
            page_images_all = convert_from_path(pdf_split)
            page_images = {i: page_images_all[i - 1] for i in need_page_image}

        # é¦–å…ˆè™•ç†è¡¨æ ¼é 
        table_blocks = []
        rotated_pages = []
        for i in table_pages:
            log(f"ğŸ“„ æª¢æŸ¥ç¬¬ {i} é è¡¨æ ¼ä½ç½®...")
            img = page_images[i]
            page = pdf.pages[i - 1]
            #å…ˆåˆ¤æ–·æ˜¯å¦éœ€è¦è½‰å‘
            ocr_result = self.reader.readtext(np.array(img))
            angle = self.detect_rotation_angle_easyocr(ocr_result)
            if angle == 90:
                img = img.rotate(-90, expand=True)
                page_images[i] = img
                ocr_result = self.reader.readtext(np.array(img))
                rotated_pages.append(i)
            #å…ˆæª¢æ¸¬è¡¨æ ¼åº§æ¨™
            inputs = self.processor(images=img, return_tensors="pt").to(self.device)
            with torch.no_grad():
                outputs = self.detector(**inputs)
            target_sizes = torch.tensor([img.size[::-1]]).to(self.device)
            results = self.processor.post_process_object_detection(outputs, threshold=0.6, target_sizes=target_sizes)[0]
            
            #é é¢é•·å¯¬
            # ç²å–é é¢é‚Šç•Œè³‡è¨Š
            #page_rect = page.rects[0]
            page_width = page.width  # è¨ˆç®—å¯¬åº¦
            page_height = page.height  # è¨ˆç®—é«˜åº¦
            page_area = page_width * page_height
            total_table_area = 0
            for j, box in enumerate(results["boxes"]):
                # è¨ˆç®—è¡¨æ ¼ä½”é é¢é¢ç©çš„æ¯”ä¾‹
                total_table_area = self.calculate_table_area_each_page(box,total_table_area)
                table_blocks = self.extract_table(img,i,j,box,table_blocks)
                
            table_area_ratio =  total_table_area / page_area if page_area > 0 else 0.0
            log(f"ç¬¬ {i} é çš„è¡¨æ ¼ä½”é é¢é¢ç©æ¯”ä¾‹ç‚ºï¼š{table_area_ratio:.2f}")
             # å¦‚æœè¡¨æ ¼ä½”æ¯”å°æ–¼50%ï¼Œé€²è¡Œæ–‡å­—å’Œåœ–ç‰‡æå–
            if table_area_ratio < 0.5:
                log(f"è¡¨æ ¼ä½”æ¯”å°æ–¼50%ï¼Œé–‹å§‹é€²è¡Œæ–‡å­—å’Œåœ–ç‰‡æå–...")
                text_results = self.extract_texts(page, i, page_images, text_results)
                image_results = self.extract_imgs(doc, i, image_results)
                
        table_results = self.group_tables_summary(table_blocks,table_results)
        # è¡¨æ ¼è™•ç†å®Œæˆå¾Œï¼Œå†è™•ç†æ²’æœ‰è¡¨æ ¼çš„é é¢
        for i, page in enumerate(pdf.pages, start=1):
            if i in table_pages:
                continue  # è·³éè¡¨æ ¼é 
            text_results = self.extract_texts(page,i,page_images,text_results)
            # è™•ç†åœ–ç‰‡
            image_results = self.extract_imgs(doc,i,image_results)
            
        if rotated_pages:
            self.rotate_original_pdf(pdf_split, rotated_pages)

        pdf.close()
        doc.close()
        end_time = time.time()
        log(f"PDF {split_index} è™•ç†å®Œæˆï¼Œç”¨æ™‚ {end_time - start_time:.2f} ç§’")

        return {"text": text_results, "table": table_results, "image": image_results}
     
    def save_results(self, result):
        result_path = os.path.join(self.output_dir, f"results.json")
        with open(result_path, "a") as f:
            json.dump(result, f)
        self.log(f"çµæœå·²å„²å­˜åˆ° {result_path}")

    def merge_pdfs(self, split_pdfs):
        """
        å°‡æ‹†åˆ†å¾Œçš„ PDF åˆä½µå›ä¸€å€‹å–®ä¸€æ–‡ä»¶ï¼Œä¸¦å°‡åˆä½µçµæœè¦†è“‹åŸå§‹çš„ PDF æª”æ¡ˆ
        """
        merged_pdf_path = os.path.join(self.output_dir, f"{self.file_stem}_merged.pdf")
        merged_doc = fitz.open()

        # åˆä½µæ‰€æœ‰æ‹†åˆ†çš„ PDF
        for split_pdf in split_pdfs:
            split_pdf_path = split_pdf
            split_doc = fitz.open(split_pdf_path)
            merged_doc.insert_pdf(split_doc)

        # å„²å­˜åˆä½µå¾Œçš„ PDF
        merged_doc.save(merged_pdf_path)
        merged_doc.close()

        # è¦†è“‹åŸå§‹çš„ PDF æª”æ¡ˆ
        os.replace(merged_pdf_path, self.pdf_path)  # æ›¿æ›ç‚ºåŸå§‹ PDF

        self.log(f"PDF å·²åˆä½µä¸¦å„²å­˜è‡³åŸå§‹æ–‡ä»¶ {self.pdf_path}")


    def optimized_process(self):
        split_pdfs = self.split_pdf()
        all_results = {"text": [], "table": [], "image": []}
        
        for split_index, split_pdf in enumerate(split_pdfs):
            split_pdf_path = split_pdf
            result = self.process(split_index, split_pdf_path)
            self.save_results(result)
            all_results["text"].extend(result["text"])
            all_results["table"].extend(result["table"])
            all_results["image"].extend(result["image"])
            
        self.merge_pdfs(split_pdfs)
        
        return all_results

if __name__ == "__main__":
    processor = PdfProcessor("test.pdf")
    result = processor.optimized_process()
